{"meta":{"title":"商企通前端","subtitle":null,"description":null,"author":null,"url":"http://yoursite.com"},"pages":[{"title":"关于我们","date":"2017-11-21T12:56:22.000Z","updated":"2017-12-14T11:57:49.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"团队简介我们是来自美团酒旅商企通的前端同学！2017年11月21日，商企通前端博客诞生。 关于团队的特点，首先最贴切的一个词是”有趣”。 有趣 大部分程序员给人的感觉也许是”技术控”,”宅”，但是我们在一起，无论是聊技术还是聊生活，无论是相互调侃还是分享网络上的段子，都能听到[哈哈哈呵呵嘿嘿哈哈哈哈]。好看的人太多，有趣的灵魂太少？ [nonono]，我们就是一个即好看又有趣的团队~ 技术控 我们当然也是一群技术控啦！热爱前端、渴望进步，我们每周都会举办技术分享或者Code review来分享成长，相互学习，如果看到公司比较好的技术分享推送，我们也会相互推荐，积极参加。 表情包 我们团队还有自己的表情包！你是不是想在评论里面发一个撒花的表情却在表情包里面找不到？自制表情包送上来~ 只要将你要发送的表情文字加上中括号即可，[撒花][开心][棒棒哒]，我们就知道你有多喜欢这篇文章了! 再也不用来回翻页找表情了! 美团的使命是让每一个人”吃得更好，活的更好”，我们的愿景是团队每一个人都可以”学得更好，玩的更好”! 团队照片 联系我们您可以随时在下方给我们留言或者通过邮件联系我们: 邮箱: shangqitong.fe@meituan.com"},{"title":"categories","date":"2017-11-21T12:40:31.000Z","updated":"2017-12-14T11:57:49.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-11-21T12:40:07.000Z","updated":"2017-12-14T11:57:49.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"webpack初识","slug":"webpack","date":"2017-12-15T02:57:09.000Z","updated":"2017-12-15T03:03:28.000Z","comments":true,"path":"2017/12/15/webpack/","link":"","permalink":"http://yoursite.com/2017/12/15/webpack/","excerpt":"webpack初识1、换个角度看webpack近年来，前端技术蓬勃发展，我们想在js更方便的实现html , 社区就出现了jsx,我们觉得原生的css不够好用，社区就提出了scss,less，针对前端项目越来越强的模块化开发需求，社区出现了AMD,CommonJS,ES2015 import等等方案。遗憾的是，这些方案大多并不直接被浏览器支持，往往伴随这些方案而生的还有另外一些，让这些新技术应用于浏览器的方案，我们用babel来转换下一代的js，转换jsx；我们用各种工具转换scss,less为css；我们发现项目越来越复杂，代码体积越来越大，又要开始寻找各种优化，压缩，分割方案。前端工程化这个过程，让我们大费精力。我们就在寻找前端模块化解决方案的过程中知晓了webpack。","text":"webpack初识1、换个角度看webpack近年来，前端技术蓬勃发展，我们想在js更方便的实现html , 社区就出现了jsx,我们觉得原生的css不够好用，社区就提出了scss,less，针对前端项目越来越强的模块化开发需求，社区出现了AMD,CommonJS,ES2015 import等等方案。遗憾的是，这些方案大多并不直接被浏览器支持，往往伴随这些方案而生的还有另外一些，让这些新技术应用于浏览器的方案，我们用babel来转换下一代的js，转换jsx；我们用各种工具转换scss,less为css；我们发现项目越来越复杂，代码体积越来越大，又要开始寻找各种优化，压缩，分割方案。前端工程化这个过程，让我们大费精力。我们就在寻找前端模块化解决方案的过程中知晓了webpack。 2、什么是webpack？（官网描述） 大话webpack： webpack 是一个现代 JavaScript 应用程序的模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成少量的 bundle - 通常只有一个，由浏览器加载。 Webpack的工作方式就是把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。 webpack是一个模块化打包工具，使用js作为载体将所有静态资源打包在一起，支持的loader和plugin等能对各种静态资源进行预处理，极大地方便了前端的工程化开发。 webpack是一个打包模块化js的工具，可以通过loader转换文件，通过plugin扩展功能。 webpack核心它是高度可配置的，先理解四个核心概念：入口(entry)、输出(output)、loader、插件(plugins)。 入口（Entry）入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中；可以指定一个或多个入口文件； 出口（Output）output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件。你可以通过在配置中指定一个 output 字段，来配置这些处理过程； 加载器（Loader）loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 在 webpack 的配置中 loader 有两个目标: 识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性) 转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(use 属性) 插件（Plugins）loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。 简要分析webpack打包后代码 1、一个立即执行函数 (function(modules){})([function(){},function(){}]); 2、匿名函数里面干了什么 定义了一个对象： installedModules = {} 定义了一个函数：__webpack_require__(moduleId){} return __webpack_require__(0) 3、webpack_require干了什么 12345678910111213141516171819202122function __webpack_require__(moduleId) &#123; // Check if module is in cache if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; // Return the exports of the module return module.exports;&#125; call能确保当模块中使用this的时候，this总是指向module.exports的： modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); 辅助开发技巧1、简化路径，定义路径别名： resolve.alias：创建 import 或 require 的别名，来确保模块引入变得更简单； resolve.extensions：自动解析确定的扩展，能够使用户在引入模块的时候不带扩展； 2、webpack中常见的占位符: [name]：代表打包后文件的名称，在entry或代码中(之后会看到)确定； [id]：webpack给块分配的内部chunk id，如果你没有隐藏，你能在打包后的命令行中看到； [hash]：每次构建过程中，生成的唯一 hash 值； [chunkhash]： 依据于打包生成文件内容的 hash 值,内容不变，值不变； [ext]： 资源扩展名,如js,jsx,png等等； 3、loader还可以实现这些： 转换编译：script-loader/babel-loader/ts-loader/coffee-loader等。 处理样式：style-loader/css-loader/less-loader/sass-loader/postcss-loader等。 处理文件：raw-loader/url-loader/file-loader/等。 处理数据：csv-loader/xml-loader等。 处理模板语言：html-loader/pug-loader/jade-loader/markdown-loader等。 清理和测试：mocha-loader/eslint-loader等。 4、CommonsChunkPlugin 提取公共模块的插件 new webpack.optimize.CommonsChunkPlugin(options) 通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，以便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。 扩展文档：如何写一个插件：https://github.com/webpack/docs/wiki/how-to-write-a-plugin","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"讲讲PWA","slug":"what-pwa","date":"2017-12-09T02:40:09.000Z","updated":"2017-12-14T11:57:49.000Z","comments":true,"path":"2017/12/09/what-pwa/","link":"","permalink":"http://yoursite.com/2017/12/09/what-pwa/","excerpt":"背景文章2017 前端大事件和趋势回顾，2018 何去何从？中提到了2017年前端值得关注的十大事件，其中就提到了PWA。","text":"背景文章2017 前端大事件和趋势回顾，2018 何去何从？中提到了2017年前端值得关注的十大事件，其中就提到了PWA。 大家都知道Native app体验确实很好，下载到手机上之后入口也方便。它也有一些缺点: 开发成本高(ios和安卓) 软件上线需要审核 版本更新需要将新版本上传到不同的应用商店 想使用一个app就必须去下载才能使用，即使是偶尔需要使用一下下 而web网页开发成本低，网站更新时上传最新的资源到服务器即可，用手机带的浏览器打开就可以使用。但是出了体验上比Native app还是差一些，还有一些明显的缺点 手机桌面入口不够便捷，想要进入一个页面必须要记住它的url或者加入书签 没网络就没响应，不具备离线能力 不像APP一样能进行消息推送 那么什么是PWA呢？ What’s PWA?PWA全称Progressive Web App，即渐进式WEB应用。 一个 PWA 应用首先是一个网页, 可以通过 Web 技术编写出一个网页应用. 随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线等功能解决了哪些问题？ 可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏 实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能 实现了消息推送 它解决了上述提到的问题，这些特性将使得 Web 应用渐进式接近原生 App。 PWA的实现Manifest实现添加至主屏幕index.html1234567&lt;head&gt; &lt;title&gt;Minimal PWA&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&gt; &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot;&gt; &lt;link rel=&quot;icon&quot; href=&quot;/e.png&quot; type=&quot;image/png&quot; /&gt;&lt;/head&gt; manifest.json12345678910111213141516171819202122232425262728&#123; &quot;name&quot;: &quot;Minimal PWA&quot;, // 必填 显示的插件名称 &quot;short_name&quot;: &quot;PWA Demo&quot;, // 可选 在APP launcher和新的tab页显示，如果没有设置，则使用name &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //用于描述应用 &quot;display&quot;: &quot;standalone&quot;, // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的 &quot;start_url&quot;: &quot;/&quot;, // 应用启动时的url &quot;theme_color&quot;: &quot;#313131&quot;, // 桌面图标的背景色 &quot;background_color&quot;: &quot;#313131&quot;, // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。 &quot;icons&quot;: [ // 桌面图标，是一个数组 &#123; &quot;src&quot;: &quot;icon/lowres.webp&quot;, &quot;sizes&quot;: &quot;48x48&quot;, // 以空格分隔的图片尺寸 &quot;type&quot;: &quot;image/webp&quot; // 帮助userAgent快速排除不支持的类型 &#125;, &#123; &quot;src&quot;: &quot;icon/lowres&quot;, &quot;sizes&quot;: &quot;48x48&quot; &#125;, &#123; &quot;src&quot;: &quot;icon/hd_hi.ico&quot;, &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot; &#125;, &#123; &quot;src&quot;: &quot;icon/hd_hi.svg&quot;, &quot;sizes&quot;: &quot;72x72&quot; &#125; ]&#125; Manifest参考文档：https://developer.mozilla.org/zh-CN/docs/Web/Manifest 可以打开网站https://developers.google.cn/web/showcase/2015/chrome-dev-summit查看添加至主屏幕的动图。 如果用的是安卓手机，可以下载chrome浏览器自己操作看看 service worker实现离线缓存什么是service workerService Worker 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力。 Service Workers 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站。 最主要的特点 在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 HTTP 请求。 网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost) 运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求 单独的作用域范围，单独的运行环境和执行线程 不能操作页面 DOM。但可以通过事件机制来处理 事件驱动型服务线程 为什么要求网站必须是HTTPS的，大概是因为service worker权限太大能拦截所有页面的请求吧，如果http的网站安装service worker很容易被攻击 浏览器支持情况 浏览器支持情况详见： https://caniuse.com/#feat=serviceworkers 生命周期 当用户首次导航至 URL 时，服务器会返回响应的网页。 第1步:当你调用 register() 函数时， Service Worker 开始下载。 第2步:在注册过程中，浏览器会下载、解析并执行 Service Worker ()。如果在此步骤中出现任何错误，register() 返回的 promise 都会执行 reject 操作，并且 Service Worker 会被废弃。 第3步:一旦 Service Worker 成功执行了，install 事件就会激活 第4步:安装完成，Service Worker 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，Service Worker 便已准备就绪，随时可以使用了！ chrome://serviceworker-internals 来了解当前浏览器中所有已安装Service Worker的详细情况 HTTP缓存与service worker缓存 HTTP缓存 Web 服务器可以使用 Expires 首部来通知 Web 客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。使用 HTTP 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期。 service worker缓存 Service Workers 的强大在于它们拦截 HTTP 请求的能力进入任何传入的 HTTP 请求，并决定想要如何响应。在你的 Service Worker 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！ 实现离线缓存index.html 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello Caching World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- Image --&gt; &lt;img src=&quot;/images/hello.png&quot; /&gt; &lt;!-- JavaScript --&gt; &lt;script async src=&quot;/js/script.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 注册 service worker if (&apos;serviceWorker&apos; in navigator) &#123; navigator.serviceWorker.register(&apos;/service-worker.js&apos;, &#123;scope: &apos;/&apos;&#125;).then(function (registration) &#123; // 注册成功 console.log(&apos;ServiceWorker registration successful with scope: &apos;, registration.scope); &#125;).catch(function (err) &#123; // 注册失败 :( console.log(&apos;ServiceWorker registration failed: &apos;, err); &#125;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注：Service Worker 的注册路径决定了其 scope 默认作用页面的范围。如果 service-worker.js 是在 /sw/ 页面路径下，这使得该 Service Worker 默认只会收到 页面/sw/ 路径下的 fetch 事件。如果存放在网站的根路径下，则将会收到该网站的所有 fetch 事件。如果希望改变它的作用域，可在第二个参数设置 scope 范围。示例中将其改为了根目录，即对整个站点生效。 service-worker.js 1234567891011121314151617181920212223242526272829303132333435363738394041var cacheName = &apos;helloWorld&apos;; // 缓存的名称// install 事件，它发生在浏览器安装并注册 Service Worker 时self.addEventListener(&apos;install&apos;, event =&gt; &#123;/* event.waitUtil 用于在安装成功之前执行一些预装逻辑 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率 安装成功后 ServiceWorker 状态会从 installing 变为 installed */ event.waitUntil( caches.open(cacheName) .then(cache =&gt; cache.addAll([ // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。 &apos;/js/script.js&apos;, &apos;/images/hello.png&apos; ])) );&#125;);/**为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。*/self.addEventListener(&apos;fetch&apos;, function (event) &#123; event.respondWith( caches.match(event.request) .then(function (response) &#123; if (response) &#123; return response; &#125; var requestToCache = event.request.clone(); // return fetch(requestToCache).then( function (response) &#123; if (!response || response.status !== 200) &#123; return response; &#125; var responseToCache = response.clone(); caches.open(cacheName) .then(function (cache) &#123; cache.put(requestToCache, responseToCache); &#125;); return response; &#125;) );&#125;); 注：为什么用request.clone()和response.clone()需要这么做是因为request和response是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 HTTP 请求还要再消耗一次，所以我们需要在此时克隆请求Clone the request—a request is a stream and can only be consumed once. 调试相关chrome浏览器打开https://googlechrome.github.io/samples/service-worker/basic/index.html，这是一个实现了service worker离线缓存功能的网站，打开调试工具 介绍一个图中的1.和2. 勾选可以模拟网站离线情况，勾选后network会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示 当前service worker的scope。它能够拦截https://googlechrome.github.io/samples/service-worker/basic/index.html下的请求，同样也能够拦截https://googlechrome.github.io/samples/service-worker/basic/\\*/\\*.html下的请求 调试面板具体代表的什么参看https://x5.tencent.com/tbs/guide/serviceworker.html的第三部分 serice worker实现消息推送 步骤一、提示用户并获得他们的订阅详细信息 步骤二、将这些详细信息保存在服务器上 步骤三、在需要时发送任何消息 不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 Google Cloud Messaging 作为推送服务为例，第一步是注册 applicationServerKey(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（endpoint），订阅对象的属性(PushSubscription.endpoint) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通）。 步骤一和步骤二index.html1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Progressive Times&lt;/title&gt; &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var endpoint; var key; var authSecret; var vapidPublicKey = &apos;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&apos;; // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用 function urlBase64ToUint8Array(base64String) &#123; const padding = &apos;=&apos;.repeat((4 - base64String.length % 4) % 4); const base64 = (base64String + padding) .replace(/\\-/g, &apos;+&apos;) .replace(/_/g, &apos;/&apos;); const rawData = window.atob(base64); const outputArray = new Uint8Array(rawData.length); for (let i = 0; i &lt; rawData.length; ++i) &#123; outputArray[i] = rawData.charCodeAt(i); &#125; return outputArray; &#125; if (&apos;serviceWorker&apos; in navigator) &#123; navigator.serviceWorker.register(&apos;sw.js&apos;).then(function (registration) &#123; return registration.pushManager.getSubscription() .then(function (subscription) &#123; if (subscription) &#123; return; &#125; return registration.pushManager.subscribe(&#123; userVisibleOnly: true, applicationServerKey: urlBase64ToUint8Array(vapidPublicKey) &#125;) .then(function (subscription) &#123; var rawKey = subscription.getKey ? subscription.getKey(&apos;p256dh&apos;) : &apos;&apos;; key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : &apos;&apos;; var rawAuthSecret = subscription.getKey ? subscription.getKey(&apos;auth&apos;) : &apos;&apos;; authSecret = rawAuthSecret ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : &apos;&apos;; endpoint = subscription.endpoint; return fetch(&apos;./register&apos;, &#123; method: &apos;post&apos;, headers: new Headers(&#123; &apos;content-type&apos;: &apos;application/json&apos; &#125;), body: JSON.stringify(&#123; endpoint: subscription.endpoint, key: key, authSecret: authSecret, &#125;), &#125;); &#125;); &#125;); &#125;).catch(function (err) &#123; // 注册失败 :( console.log(&apos;ServiceWorker registration failed: &apos;, err); &#125;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 步骤三 服务器发送消息给service worker app.js123456789101112131415161718192021222324252627282930313233343536const webpush = require(&apos;web-push&apos;);const express = require(&apos;express&apos;);var bodyParser = require(&apos;body-parser&apos;);const app = express();webpush.setVapidDetails( &apos;mailto:contact@deanhume.com&apos;, &apos;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&apos;, &apos;p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0&apos;);app.post(&apos;/register&apos;, function (req, res) &#123; var endpoint = req.body.endpoint; saveRegistrationDetails(endpoint, key, authSecret); const pushSubscription = &#123; endpoint: req.body.endpoint, keys: &#123; auth: req.body.authSecret, p256dh: req.body.key &#125; &#125;; var body = &apos;Thank you for registering&apos;; var iconUrl = &apos;https://example.com/images/homescreen.png&apos;; // 发送 Web 推送消息 webpush.sendNotification(pushSubscription, JSON.stringify(&#123; msg: body, url: &apos;http://localhost:3111/&apos;, icon: iconUrl &#125;)) .then(result =&gt; res.sendStatus(201)) .catch(err =&gt; &#123; console.log(err); &#125;);&#125;);app.listen(3111, function () &#123; console.log(&apos;Web push app listening on port 3111!&apos;)&#125;); service worker监听push事件，将通知详情推送给用户 service-worker.js12345678910111213self.addEventListener(&apos;push&apos;, function (event) &#123; // 检查服务端是否发来了任何有效载荷数据 var payload = event.data ? JSON.parse(event.data.text()) : &apos;no payload&apos;; var title = &apos;Progressive Times&apos;; event.waitUntil( // 使用提供的信息来显示 Web 推送通知 self.registration.showNotification(title, &#123; body: payload.msg, url: payload.url, icon: payload.icon &#125;) );&#125;); 扩展知识：service worker的更新 总结PWA的优势 可以将app的快捷方式放置到桌面上，全屏运行，与原生app无异 能够在各种网络环境下使用，包括网络差和断网条件下，不会显示undefind 推送消息的能力 其本质是一个网页，没有原生app的各种启动条件，快速响应用户指令PWA存在的问题 支持率不高:现在ios手机端不支持pwa，IE也暂时不支持 Chrome在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低 各大厂商还未明确支持pwa 依赖的GCM服务在国内无法使用 微信小程序的竞争 尽管有上述的一些缺点，PWA技术仍然有很多可以使用的点。 service worker技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。 service worker实现消息推送，使用浏览器推送功能，吸引用户 渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验。 参考文档 第一本 PWA 中文书 PWA 英文书 网站渐进式增强体验(PWA)改造：Service Worker 应用详解 Basic Service Worker Sample 【翻译】Service Worker 入门 Web App Manifest Service Workers: an Introduction The Offline Cookbook 微信小程序和PWA对比分析 Service Worker最佳实践","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"pwa","slug":"pwa","permalink":"http://yoursite.com/tags/pwa/"}]},{"title":"node+express实现图片上传功能","slug":"node-express","date":"2017-11-27T05:27:26.000Z","updated":"2017-12-14T11:57:49.000Z","comments":true,"path":"2017/11/27/node-express/","link":"","permalink":"http://yoursite.com/2017/11/27/node-express/","excerpt":"概述本篇文章适用于node刚刚入门的读者。 本篇文章使用node+express实现了一个简单的图片上传功能：用户点击图片上传，会跳转到上传成功页面并展示上传的图片。","text":"概述本篇文章适用于node刚刚入门的读者。 本篇文章使用node+express实现了一个简单的图片上传功能：用户点击图片上传，会跳转到上传成功页面并展示上传的图片。 前言一直想找资料入门node，试着一步步实现一个功能，都没有合适的资料。直到看到https://www.nodebeginner.org/index-zh-cn.html# ，这本书教你如何一步一步结合基本的API搭建一个简单的应用，实现了简单的图片上传功能。我看完之后终于感觉自己基本入门node了。文章中有附源码地址，https://github.com/manuelkiessling/nodebeginner.org/tree/master/code/application ，如果你感觉还没有入门node，可以试试这本书。 当然我的建议是跟着教程一步步修改代码，而不是直接将源码clone下来。 问题文章到后面给出页面展示的html是以response.write(body);的方式写的 123456789101112131415161718192021function start(response) &#123;console.log(&quot;Request handler &apos;start&apos; was called.&quot;);var body = &apos;&lt;html&gt;&apos;+&apos;&lt;head&gt;&apos;+&apos;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; &apos;+&apos;charset=UTF-8&quot; /&gt;&apos;+&apos;&lt;/head&gt;&apos;+&apos;&lt;body&gt;&apos;+&apos;&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; &apos;+&apos;method=&quot;post&quot;&gt;&apos;+&apos;&lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt;&apos;+&apos;&lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&gt;&apos;+&apos;&lt;/form&gt;&apos;+&apos;&lt;/body&gt;&apos;+&apos;&lt;/html&gt;&apos;;response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/html&quot;&#125;);response.write(body);response.end();&#125; 实际应用中肯定不能以这样的方式写html文件，所以接下来就教你用node+express实现同样的功能，使我们的代码看起来更优雅 node+express实现图片上传功能环境mac+node(v9.2.0)+express 安装express express官网:http://www.expressjs.com.cn/ 新建文件夹node-app，在文件夹下新建package.json文件 1234567&#123; &quot;name&quot;: &quot;node-app&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.2&quot;, &#125;&#125; 运行npm install。新建app.js，代码如下 12345678910111213var express = require(&apos;express&apos;);var app = express();app.get(&apos;/&apos;, function (req, res) &#123; res.send(&apos;Hello World!&apos;);&#125;);var server = app.listen(3000, function () &#123; var host = server.address().address; var port = server.address().port; console.log(&apos;Example app listening at http://%s:%s&apos;, host, port);&#125;); 运行node app.js，打开localhost:3000，应用已经跑起来了 利用 Express 托管静态文件下面利用 Express 托管静态文件，在node-app下新建文件夹public，新建两个html文件 start.html 123456789101112&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt;请上传您的文件&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;./upload.html&quot; enctype=&quot;multipart/form-data&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; upload.html 12345678910&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt;上传成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;上传成功&lt;/h1&gt; &lt;img src=&quot;/public/test.png&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 修改app.js，增加app.use(&#39;/public&#39;, express.static(&#39;public&#39;));。修改后app.js如下123456789101112131415var express = require(&apos;express&apos;);var app = express();app.get(&apos;/&apos;, function (req, res) &#123; res.send(&apos;Hello World!&apos;);&#125;);app.use(&apos;/public&apos;, express.static(&apos;public&apos;));var server = app.listen(3000, function () &#123; var host = server.address().address; var port = server.address().port; console.log(&apos;Example app listening at http://%s:%s&apos;, host, port);&#125;); 现在，public 目录下面的文件就可以访问了。 参考文档：http://www.expressjs.com.cn/starter/static-files.html 重启node服务，打开http://localhost:3000/public/start.html，选择文件上传之后，页面就会自动跳转到上传成功页面 处理上传的图片使用模块formidable处理请求数据。在package.json中增加 1234&quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;^4.16.2&quot;, &quot;formidable&quot;: &quot;^1.1.1&quot;&#125; 运行npm install。 文件上传自然要用到post请求,更改start.html，改为method=&quot;post&quot; 1234&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;upload&quot; multiple=&quot;multiple&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload file&quot; /&gt;&lt;/form&gt; 处理post请求用到的Express的路由 参考 http://www.expressjs.com.cn/starter/basic-routing.html 修改后的app.js如下： 12345678910111213141516171819202122232425262728var express = require(&apos;express&apos;);var app = express();var formidable = require(&quot;formidable&quot;);fs = require(&quot;fs&quot;);app.get(&apos;/&apos;, function (req, res) &#123; res.send(&apos;Hello World!&apos;);&#125;);app.use(&apos;/public&apos;, express.static(&apos;public&apos;));app.post(&apos;/upload&apos;, function (req, res) &#123; var form = new formidable.IncomingForm(); console.log(&quot;about to parse&quot;); form.parse(req, function(error, fields, files) &#123; console.log(&quot;parsing done&quot;); console.log(files.upload.path); fs.writeFileSync(&quot;public/test.png&quot;, fs.readFileSync(files.upload.path)); res.redirect(&quot;/public/upload.html&quot;) ; &#125;);&#125;);var server = app.listen(3000, function () &#123; var host = server.address().address; var port = server.address().port; console.log(&apos;Example app listening at http://%s:%s&apos;, host, port);&#125;); 在public文件夹下新增upload.html, 12345678910&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt;上传成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;上传成功&lt;/h1&gt; &lt;img src=&quot;/public/test.png&quot;/&gt;&lt;/body&gt;&lt;/html&gt; 嗯，大功告成啦。重新启动服务，打开 http://localhost:3000/public/start.html 选择一个图片上传，就能看到自己上传的图片了！ 源码附上，https://github.com/Lie8466/node-app/tree/node-express 感谢您的阅读！这是我的学习过程，希望对你有所帮助~ 参考文档https://www.nodebeginner.org/index-zh-cn.html#","categories":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/categories/前端开发/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"Weex的原生开发实践","slug":"weex","date":"2017-11-21T07:54:00.000Z","updated":"2017-12-14T11:57:49.000Z","comments":true,"path":"2017/11/21/weex/","link":"","permalink":"http://yoursite.com/2017/11/21/weex/","excerpt":"weex概念与特性 最形象的理解就是类似react native。 Weex几大特点： 1.帮助你构建原生应用与 Web App、HTML5 App 或 hybrid App 不同，您可以使用 Weex 构建一个真正的原生应用。更贴心的是你的代码只需使用 HTML、CSS、JavaScript 可以构建原生应用，上手非常简单。但实际上，应用的底层是 Objective-C 或 Java， 同时，Weex 提供很多 native 组件或模块供开发人员使用。 2.一次编写，多端运行Weex 提供强大的跨平台能力，可以使用相同的 API 开发 Web，Android 和 iOS 应用。 同时，我们对接口了丰富的扩展能力。 这样，当您需要扩展原生组件或模块时，这将非常方便。","text":"weex概念与特性 最形象的理解就是类似react native。 Weex几大特点： 1.帮助你构建原生应用与 Web App、HTML5 App 或 hybrid App 不同，您可以使用 Weex 构建一个真正的原生应用。更贴心的是你的代码只需使用 HTML、CSS、JavaScript 可以构建原生应用，上手非常简单。但实际上，应用的底层是 Objective-C 或 Java， 同时，Weex 提供很多 native 组件或模块供开发人员使用。 2.一次编写，多端运行Weex 提供强大的跨平台能力，可以使用相同的 API 开发 Web，Android 和 iOS 应用。 同时，我们对接口了丰富的扩展能力。 这样，当您需要扩展原生组件或模块时，这将非常方便。 3.支持 Vue 语法Weex 遵循 Web 标准，同时支持 vue.js 的语法。因此，您可以使用 vue.js 语法来开发应用程序 weexpack weexpack 是新一代的weex应用工程和插件工程开发套件，是基于weex快速搭建应用原型的利器。它能够帮助开发者通过命令行创建weex应用工程和插件工程，快速打包 weex 应用并安装到手机运行，对于具有分享精神的开发者而言还能够创建weex插件模版并发布插件到weex应用市场。 使用weexpack 能够方便的在在weex工程和native工程中安装插件。具体介绍见：https://github.com/weexteam/weex-pack 原生开发之路 创建工程首先，全局安装weexpack1$ npm install -g weexpack 然后，创建工程1weexpack create weexpack-demo 安装依赖1cd weexpack-demo &amp;&amp; npm install 生成的目录结构如下： 添加平台应用模版*我这里添加的是Android1$ weexpack platform add android 添加成功后platforms目录下会多出一个android目录 调试这里的调试我们可以通过https://weex.apache.org/cn/guide/tools/toolkit.html的方法来进行调试。这个调试分两种：在浏览器上进行网页调试通过Playground 在手机上扫描调试但是这两种感觉Biger不够，我想要开发原生应用的free-使用真机来调试。 真机开发调试这里就需要用到Android Studio了，下载AS，安装JDK，配置环境变量这是前置步骤。这里就不再赘述这些流程了，我相信你可以（网上很多教程）。当前置的步骤全部完成时，我们就要开始进入大坑了。1.第一个坑weex推荐使用weex run android命令来运行起安卓应用，但是很快会报错No android devices found. Chrome中开的服务是可以的 你可能会疑问，我已经通过USB链接了手机为何还是不行？这个坑一般会耽误你一天左右时间。 解决方案：使用Android Studio打开我们的weex应用。 2.第二个坑使用AS打开应用的时候没有发现Android应用 解决方案：应该打开weex下的platforms/android。具体可以看：https://segmentfault.com/q/1010000010652802 选择安卓文件后，AS需要安装很多东西，稍等下，一般较长时间。报错信息只要按照AS的提示进行安装即可。等一切完毕后，运行安卓项目。 手机上的效果 模拟器开发调试并自动热更新这篇文章Android Studio集成到Genymotion模拟器已经告诉了我们如何集成模拟器 在我们的weex项目中运行下面这个命令，将会将native JSbundle替换成新的。1234567891011121314151617181920212223242526$ weexpack run android...:weexplugin:compileDebugShaders:weexplugin:generateDebugAssets:weexplugin:mergeDebugAssets:weexplugin:mergeDebugProguardFiles:weexplugin:packageDebugRenderscript UP-TO-DATE:weexplugin:processDebugJavaRes UP-TO-DATE:weexplugin:transformResourcesWithMergeJavaResForDebug UP-TO-DATE:weexplugin:transformClassesAndResourcesWithSyncLibJarsForDebug UP-TO-DATE:weexplugin:mergeDebugJniLibFolders UP-TO-DATE:weexplugin:transformNativeLibsWithMergeJniLibsForDebug UP-TO-DATE:weexplugin:transformNativeLibsWithSyncJniLibsForDebug UP-TO-DATE:weexplugin:bundleDebug UP-TO-DATE:weexplugin:compileDebugSources UP-TO-DATE:weexplugin:assembleDebug UP-TO-DATE:weexplugin:compileReleaseSources:weexplugin:assembleRelease:weexplugin:assembleBUILD SUCCESSFULTotal time: 7.404 secs =&gt; Install app ... =&gt; Running app ... 这时候在AS中会提示你有代码需要同步。 点击同步后，模拟器自动更新。","categories":[{"name":"原生开发","slug":"原生开发","permalink":"http://yoursite.com/categories/原生开发/"}],"tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}]}]}